package com.skysoft.util;

import java.io.BufferedInputStream;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.OutputStreamWriter;
import java.io.UnsupportedEncodingException;
import java.net.HttpURLConnection;
import java.net.URL;
import java.sql.Blob;
import java.sql.Clob;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import javax.sql.rowset.serial.SerialBlob;
import javax.sql.rowset.serial.SerialClob;
import javax.sql.rowset.serial.SerialException;

import org.apache.commons.io.IOUtils;

/**
 * 文件流处理工具类
 */
public class FileUtils {

    /**
     * 删除整个目录，包含所有子目录和文件
     *
     * @param path
     */
    public static void deleteDirs(String path) {
        File rootFile = new File(path);
        if (!rootFile.exists()) {
            return;
        }
        File[] files = rootFile.listFiles();
        if (null == files) {
            return;
        }
        for (int i = 0; i < files.length; i++) {
            File file = files[i];
            if (file.isDirectory()) {
                deleteDirs(file.getPath());
            } else {
                file.delete();
            }
        }
        rootFile.delete();
    }

    /**
     * 删除指定文件
     *
     * @param filePath
     * @return
     */
    public static boolean deleteFile(String filePath) {
        File file = new File(filePath);
        if (!file.exists()) {
            return false;
        }
        return file.delete();
    }

    /**
     * 文件复制
     *
     * @param is    输入流
     * @param os    输出流
     * @param close 写入之后是否需要关闭OutputStream
     * @throws IOException
     */
    public static int copy(InputStream is, OutputStream os, boolean close) {
        try {
            return IOUtils.copy(is, os);
        } catch (IOException e1) {
            e1.printStackTrace();
        } finally {
            if (close) {
                try {
                    is.close();
                    os.close();
                } catch (IOException e2) {
                    e2.printStackTrace();
                }
            }
        }
        return 0;
    }

    /**
     * 文件复制
     *
     * @param inputName
     * @param outputName
     * @return
     */
    public static boolean copyFile(String inputName, String outputName) {
        InputStream is = null;
        OutputStream os = null;
        int copyed = 0;
        try {
            is = new FileInputStream(inputName);
            os = new FileOutputStream(outputName);
            copyed = copy(is, os, true);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return copyed > 0;
    }

    /**
     * 文件夹复制
     *
     * @param srcFolder
     * @param destFolder
     * @return
     */
    public static boolean copyDirctory(String srcFolder, String destFolder) {
        File srcFile = new File(srcFolder);
        File destFile = new File(destFolder);
        if (!srcFile.exists() || (srcFile.isDirectory() && destFile.isFile())) {
            return false;
        }
        //文件copy到文件
        if (srcFile.isFile() && destFile.isFile()) {
            return copyFile(srcFolder, destFolder);
        }
        //创建目标目录
        if (!destFile.exists() && !destFile.isFile()) {
            destFile.mkdir();
        }
        //文件copy到目录
        if (srcFile.isFile()) {
            String srcFileName = srcFile.getName();
            String destFilePath = wrapFilePath(getFullFilePath(srcFileName, destFolder));
            return copyFile(wrapFilePath(srcFolder), destFilePath);
        }

        //目录copy到目录
        File[] allFiles = srcFile.listFiles();
        String srcName = null;
        String desName = null;
        for (File file : allFiles) {
            srcName = file.getName();
            if (file.isFile()) {
                desName = wrapFilePath(getFullFilePath(srcName, destFolder));
                copyFile(wrapFilePath(file.getAbsolutePath()), desName);
            } else {
                copyDirctory(wrapFilePath(file.getAbsolutePath()), getFullFilePath(srcName, destFolder));
            }
        }
        return true;
    }

    /**
     * 得到某文件夹下的所有文件
     *
     * @param path
     * @return
     */
    public static List<File> getAllFile(String path) {
        File file = new File(path);
        File[] files = file.listFiles();
        List<File> fileList = new ArrayList<File>();
        for (File f : files) {
            if (f.isFile()) {
                fileList.add(f);
            }
        }
        return fileList;
    }

    /**
     * 读取文件
     *
     * @param filePath
     * @return
     * @throws IOException
     */
    public static String readFile(String filePath) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(new File(filePath)));
        StringBuffer content = new StringBuffer();
        String line = null;
        while ((line = in.readLine()) != null) {
            content.append(line).append("\n");
        }
        return content.toString().replaceAll("\n$", "");
    }

    /**
     * 读取文件
     *
     * @param file
     * @return
     * @throws IOException
     */
    public static String readFile(File file) throws IOException {
        BufferedReader in = new BufferedReader(new FileReader(file));
        StringBuffer content = new StringBuffer();
        String line = null;
        while ((line = in.readLine()) != null) {
            content.append(line).append("\n");
        }
        return content.toString().replaceAll("\n$", "");
    }

    /**
     * 把字符串以指定编码写入文件，<br/>可以指定写入方式：追加/覆盖
     *
     * @param content  写入的字符串
     * @param filePath 文件保存路径
     * @param charset  写入编码
     * @param append   是否追加
     */
    public static void writeFile(String content, String filePath, String charset, boolean append) {
        BufferedWriter writer = null;
        OutputStream os = null;
        OutputStreamWriter osw = null;
        try {
            os = new FileOutputStream(filePath, append);
            osw = new OutputStreamWriter(os, charset);
            writer = new BufferedWriter(osw);
            writer.write(content);
            writer.flush();
        } catch (Exception e) {
            e.printStackTrace();
        } finally {
            try {
                os.close();
                osw.close();
                writer.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
    }

    /**
     * 把字符串以指定编码写入文件，<br/>可以指定写入方式：追加/覆盖
     * <br/>默认写入方式为覆盖
     *
     * @param content  写入的字符串
     * @param filePath 文件保存路径
     * @param charset  写入编码
     */
    public static void writeFile(String content, String filePath, String charset) {
        writeFile(content, filePath, charset, false);
    }

    /**
     * 把字符串以指定编码写入文件，<br/>可以指定写入方式：追加/覆盖
     * <br/>默认写入编码为UTF-8
     *
     * @param content  写入的字符串
     * @param filePath 文件保存路径
     * @param append   是否追加
     */
    public static void writeFile(String content, String filePath, boolean append) {
        writeFile(content, filePath, "UTF-8", append);
    }

    /**
     * 把字符串以指定编码写入文件，<br/>可以指定写入方式：追加/覆盖
     * <br/>默认写入方式为覆盖,默认写入编码为UTF-8
     *
     * @param content  写入的字符串
     * @param filePath 文件保存路径
     */
    public static void writeFile(String content, String filePath) {
        writeFile(content, filePath, "UTF-8", false);
    }

    /**
     * 下载文件
     *
     * @param link
     * @param filePath
     * @throws IOException
     */
    public static void download(String link, String filePath)
            throws IOException {
        URL url = new URL(link);
        BufferedReader in = new BufferedReader(new InputStreamReader(
                url.openStream()));
        String inputLine = null;
        FileOutputStream fos = new FileOutputStream(filePath);
        while ((inputLine = in.readLine()) != null) {
            fos.write(inputLine.getBytes());
        }
        in.close();
        fos.close();
    }

    /**
     * 获取远程文件的输入流
     *
     * @param url
     * @return
     */
    public static byte[] getBinaryDataFromURL(String link) throws IOException {
        BufferedInputStream bis = null;
        HttpURLConnection httpUrl = null;
        URL url = null;
        try {
            url = new URL(link);
            httpUrl = (HttpURLConnection) url.openConnection();
            httpUrl.connect();
            bis = new BufferedInputStream(httpUrl.getInputStream());
            return inputStream2ByteArray(bis);
        } catch (IOException e) {
            return null;
        } finally {
            httpUrl.disconnect();
        }
    }

    /**
     * 字符串转换成Clob
     *
     * @param string
     * @return
     */
    public static Clob string2Clob(String string) {
        if (GerneralUtils.isEmptyString(string)) {
            return null;
        }
        try {
            return new SerialClob(string.toCharArray());
        } catch (SerialException e) {
            return null;
        } catch (SQLException e) {
            return null;
        }
    }

    /**
     * Clob转换成字符串
     *
     * @param clob
     * @return
     */
    public static String clob2String(Clob clob) {
        if (null == clob) {
            return null;
        }
        try {
            return clob.getSubString(1L, (int) clob.length());
        } catch (SQLException e) {
            return null;
        }
    }

    /**
     * 字节数组转换成Clob
     *
     * @param byteArray
     * @param charsetName
     * @return
     */
    public static Clob byteArray2Clob(byte[] byteArray, String charsetName) {
        if (null == byteArray) {
            return null;
        }
        try {
            String string = new String(byteArray,
                    charsetName == null ? Constant.DEFAULT_CHARSET
                            : charsetName);
            return string2Clob(string);
        } catch (UnsupportedEncodingException e) {
            return null;
        }
    }

    /**
     * 字节数组转换成Clob(重载) 若不显式指定编码，默认编码为UTF-8
     *
     * @param byteArray
     * @param charsetName
     * @return
     */
    public static Clob byteArray2Clob(byte[] byteArray) {
        return byteArray2Clob(byteArray, null);
    }

    /**
     * Clob转换成字节数组
     *
     * @param clob
     * @return
     */
    public static byte[] clob2ByteArray(Clob clob) {
        if (null == clob) {
            return null;
        }
        InputStream in = null;
        byte[] byteArray = null;
        int length = 0;
        try {
            length = (int) clob.length();
            byteArray = new byte[length];
            in = clob.getAsciiStream();
        } catch (SQLException e) {
            return null;
        }
        int offset = 0;
        int n = 0;
        try {
            do {
                n = in.read(byteArray, offset, length - offset);
            } while (n != -1);
        } catch (IOException e) {
            return null;
        } finally {
            try {
                in.close();
            } catch (IOException e) {
                e.printStackTrace();
            }
        }
        return byteArray;
    }

    /**
     * 字节数组转换成Blob
     *
     * @param byteArray
     * @return
     * @throws SQLException
     * @throws SerialException
     */
    public static Blob byteArray2Blob(byte[] byteArray) {
        if (null == byteArray) {
            return null;
        }
        try {
            return new SerialBlob(byteArray);
        } catch (SerialException e) {
            return null;
        } catch (SQLException e) {
            return null;
        }
    }

    /**
     * Blob转换成字节数组
     *
     * @param blob
     * @return
     */
    public static byte[] blob2ByteArray(Blob blob) {
        BufferedInputStream is = null;
        try {
            is = new BufferedInputStream(blob.getBinaryStream());
            byte[] bytes = new byte[(int) blob.length()];
            int len = bytes.length;
            int offset = 0;
            int read = 0;
            while (offset < len
                    && (read = is.read(bytes, offset, len - offset)) != -1) {
                offset += read;
            }
            return bytes;
        } catch (SQLException e) {
            return null;
        } catch (IOException e) {
            return null;
        } finally {
            try {
                is.close();
                is = null;
            } catch (IOException e) {
                return null;
            }
        }
    }

    /**
     * 字节数组转换成输入流
     *
     * @param byteArray 字节数组
     * @return
     */
    public static InputStream byteArray2InputStream(byte[] byteArray) {
        return new ByteArrayInputStream(byteArray);
    }

    /**
     * 输入流转换成字节数组
     *
     * @param is 输入流对象
     * @return
     * @throws IOException
     */
    public static byte[] inputStream2ByteArray(InputStream is)
            throws IOException {
        ByteArrayOutputStream bytestream = new ByteArrayOutputStream();
        int ch = 0;
        while ((ch = is.read()) != -1) {
            bytestream.write(ch);
        }
        byte imgdata[] = bytestream.toByteArray();
        bytestream.close();
        is.close();
        return imgdata;
    }

    /**
     * String转换成输入流
     *
     * @param text
     * @param charset
     * @return
     */
    public static InputStream string2InputStream(String text, String charset) {
        try {
            return new ByteArrayInputStream(text.getBytes(charset));
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 输入流转换成String(速度快但耗内存)
     *
     * @param is
     * @return
     * @throws IOException
     */
    public static String inputStream2String(InputStream is) throws IOException {
        BufferedReader in = new BufferedReader(new InputStreamReader(is));
        StringBuffer buffer = new StringBuffer();
        String line = "";
        while ((line = in.readLine()) != null) {
            buffer.append(line).append("\n");
        }
        return buffer.toString();
    }

    /**
     * 输入流转换成String(消耗资源少但速度慢)
     *
     * @param is
     * @return
     * @throws IOException
     */
    public static String inputStreamToString(InputStream is) throws IOException {
        ByteArrayOutputStream bos = new ByteArrayOutputStream();
        byte[] bt = new byte[4096];
        int i = -1;
        while ((i = is.read(bt)) > 0) {
            bos.write(bt, 0, i);
        }
        return bos.toString();
    }

    /**
     * 文件转换成输入流
     *
     * @param file
     * @return
     */
    public static InputStream file2InputStream(File file) {
        try {
            return new FileInputStream(file);
        } catch (FileNotFoundException e) {
            e.printStackTrace();
        }
        return null;
    }

    /**
     * 输入流写入文件
     *
     * @param is       输入流
     * @param filePath 文件保存目录路径
     * @throws IOException
     */
    public static void write2File(InputStream is, String filePath)
            throws IOException {
        OutputStream os = new FileOutputStream(filePath);
        int len = 8192;
        byte[] buffer = new byte[len];
        while ((len = is.read(buffer, 0, len)) != -1) {
            os.write(buffer, 0, len);
        }
        os.close();
        is.close();
    }

    /**
     * 输入流写入文件
     *
     * @param is       输入流
     * @param filePath 文件保存目录路径
     * @param append   是否追加
     * @throws IOException
     */
    public static void write2File(InputStream is, String filePath, boolean append)
            throws IOException {
        OutputStream os = new FileOutputStream(filePath, append);
        int len = 8192;
        byte[] buffer = new byte[len];
        while ((len = is.read(buffer, 0, len)) != -1) {
            os.write(buffer, 0, len);
        }
        os.close();
        is.close();
    }

    /**
     * 获取文件的完整路径
     *
     * @param fileName 文件名称
     * @param filePath 文件保存路径
     * @return
     */
    public static String getFullFilePath(String fileName, String filePath) {
        if (GerneralUtils.isEmptyString(filePath)
                || GerneralUtils.isEmptyString(fileName)) {
            return null;
        }
        filePath = wrapFilePath(filePath);
        return filePath + fileName;
    }

    /**
     * 转换文件路径中的\\为/
     *
     * @param filePath
     * @return
     */
    public static String wrapFilePath(String filePath) {
        if (filePath.split("\\\\").length > 1) {
            filePath = filePath.replace("\\", "/");
        }
        if (!filePath.endsWith("/")) {
            filePath = filePath + "/";
        }
        return filePath;
    }

    /**
     * 从文件路径中获取文件所在路径
     *
     * @param fullPath 文件全路径
     * @return 文件所在路径
     */
    public static String getFileDir(String fullPath) {
        int iPos1 = fullPath.lastIndexOf("/");
        int iPos2 = fullPath.lastIndexOf("\\");
        if (-1 == iPos1 && -1 == iPos2) {
            return fullPath;
        }
        iPos1 = (iPos1 > iPos2 ? iPos1 : iPos2);
        return fullPath.substring(0, iPos1 + 1);
    }

    /**
     * 从文件路径中获取文件名称(包含后缀名)
     *
     * @param fullPath
     * @return
     */
    public static String getFileName(String fullPath) {
        if (GerneralUtils.isEmptyString(fullPath)) {
            return "";
        }
        int iPos1 = fullPath.lastIndexOf("/");
        int iPos2 = fullPath.lastIndexOf("\\");
        if (-1 == iPos1 && -1 == iPos2) {
            return fullPath;
        }
        iPos1 = (iPos1 > iPos2 ? iPos1 : iPos2);
        return fullPath.substring(iPos1 + 1);
    }

    /**
     * 从URL链接中提取文件名称
     *
     * @param url
     * @return
     */
    public static String getFileNameFromUrl(String url) {
        if (GerneralUtils.isEmptyString(url)) {
            return "";
        }
        if (url.endsWith("/")) {
            url = url.substring(0, url.length() - 1);
        }
        url = url.replaceAll("(?:http|https)://www\\.([\\s\\S]*)", "$1");
        return getFileName(url);
    }

    /**
     * 从文件路径中获取文件名称(去除后缀名)
     *
     * @param fullPath
     * @return
     */
    public static String getPureFileName(String fullPath) {
        String fileFullName = getFileName(fullPath);
        int index = fileFullName.lastIndexOf(".");
        if (index != -1) {
            return fileFullName.substring(0, index);
        }
        return fileFullName;
    }

    /**
     * 获得文件名中的后缀名
     *
     * @param fileName 源文件名
     * @return String 后缀名
     */
    public static String getFileSuffix(String fileName) {
        int index = fileName.lastIndexOf(".");
        if (index != -1) {
            return fileName.substring(index + 1, fileName.length());
        }
        return fileName;
    }

    /**
     * 从CLASSPATH路径下加载指定文件
     *
     * @param fileName 文件名称
     * @return
     */
    public static String getFileFromClassPath(String fileName) {
        URL url = FileUtils.class.getClassLoader().getResource(fileName);
        String filepath = url.getFile();
        File file = new File(filepath);
        byte[] retBuffer = new byte[(int) file.length()];
        try {
            FileInputStream fis = new FileInputStream(filepath);
            fis.read(retBuffer);
            fis.close();
            return new String(retBuffer, "UTF-8");
        } catch (IOException e) {
            return null;
        }
    }

    /**
     * 从URL链接中猜测文件名称
     *
     * @param url
     * @return
     */
    public static String guessFileNameFromUrl(String url) {
        String reg = "(/|=)([^/&?]+\\.[a-zA-Z]+)";
        if (GerneralUtils.isEmptyString(url) || Pattern.compile(reg).matcher(url).find()) {
            return "UnknowName.temp";
        }
        Matcher matcher = Pattern.compile(reg).matcher(url);
        String s = "";
        while (matcher.find()) {
            s = matcher.group(2);
        }
        return s;
    }

    /**
     * 从Content-Disposition中提取文件名
     *
     * @param contentDisposition
     * @return
     */
    public static String getFileNameFromContentDisposition(String contentDisposition) {
        if (GerneralUtils.isEmptyString(contentDisposition)) {
            return "UnknowName.temp";
        }
        if (!contentDisposition.startsWith("attachment")) {
            return null;
        }
        return contentDisposition.substring(contentDisposition.indexOf("=") + 1);
    }
}
